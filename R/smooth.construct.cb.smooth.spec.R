###
### R routines for the R package dlnm (c) Antonio Gasparrini and Fabian Scheipl 2016
#


#' Cross-Basis Spline Smooths for a DLNM
#' 
#' These functions define a smooth class for bi-dimensional cross-basis splines
#' for penalized DLMs and DLNMs. The functions are not supposed to be called
#' directly, and the class is usually specified via terms like
#' \code{s(X,L,bs="cb",...)} in the formula of the \code{\link[mgcv]{gam}}
#' function of the package \pkg{mgcv}.
#' 
#' These functions embed tools available in the packages \pkg{dlnm} and
#' \pkg{mgcv} to perform penalized DLMs and DLNMs. This represent the
#' \emph{internal} method to perform such models (see Notes below).
#' Specifically, the models are fitted by including a term
#' \code{s(X,L,bs="cb",...)}, defining a class \code{"cb"} for bi-dimensional
#' cross-basis splines, in the formula of the \code{\link[mgcv]{gam}} function.
#' The smooth constructor function for this class turns this smooth terms into
#' a smooth specification object, which includes the cross-basis matrix (see
#' \code{\link{crossbasis}}) and the penalty matrices for the two spaces of
#' predictor and lags used in model fitting. Then, \code{\link{crosspred}} uses
#' the predict matrix function for the \code{"cb"} class to obtain predictions,
#' and a graphical representation can be obtained by standard
#' \code{\link[=plot.crosspred]{plotting functions}}, similary to unpenalized
#' models.
#' 
#' The first two arguments \code{X} and \code{L} in \code{\link[mgcv]{s}}
#' represent a matrix of exposure histories and a matrix of lags. The former,
#' also used in \code{\link{crossbasis}}, needs to be defined directly even
#' with time series data by lagging the exposure series. The matrix \code{L}
#' must have the same dimensions of \code{X}, with identical rows representing
#' the sequence of lags. The other arguments of \code{\link[mgcv]{s}} have the
#' same meaning: in particular, \code{k} (default to 10), \code{fx} (default to
#' \code{FALSE}) and \code{sp} (default to \code{NULL}) can be provided for
#' each marginal basis as vectors of length 2, and similarly \code{m} can be
#' provided as a list (see also \code{\link[mgcv]{te}}). No \code{by} argument
#' is allowed.
#' 
#' Extra information can be included in the argument \code{xt} of
#' \code{\link[mgcv]{s}}, which accepts a single object or a list of objects.
#' First, an object \code{bs} (a vector of length 1 or 2) can be used to
#' specify the smoother for each marginal dimension, with current options
#' restricted to \code{"ps"}
#' (\code{\link[=smooth.construct.ps.smooth.spec]{P-splines}}, used by default)
#' and/or \code{"cr"} (\code{\link[=smooth.construct.cr.smooth.spec]{cubic
#' regression splines}}). Second, list objects \code{argvar} and \code{arglag}
#' can be used to build the marginal bases for predictor and lags by calling
#' other functions (see the same arguments in \code{\link{crossbasis}}). In
#' particular, these can be used for a more flexible specification of penalized
#' functions (using \code{\link{ps}} or \code{\link{cr}}) or for using
#' unpenalized functions for one marginal basis, thus limiting the penalization
#' to one of the two dimensions. Third, the object \code{addSlag} can contain a
#' matrix or vector (or list of matrices and/or vectors) defining additional
#' penalties on the lag structure (see \code{\link{cbPen}}).
#' 
#' @aliases smooth.construct.cb.smooth.spec Predict.matrix.cb.smooth
#' @param object a smooth specification object, usually generated by a term
#' \code{s(X,L,bs="cb",...)}.
#' @param data a list containing just the data (including any by variable)
#' required by this term, with names corresponding to \code{object$term}.
#' @param knots a list containing any knots supplied for basis setup --- in
#' same order and with same names as data. It is usually \code{NULL}.
#' @return The smooth constructor function returns an object of classes
#' \code{"cb.smooth"} and \code{"tensor.smooth"}. Specifically, a list with a
#' similar structure of that returned by the smooth constructor for
#' \code{\link[=smooth.construct.tensor.smooth.spec]{tensor product smooths}}
#' (see also \code{\link[mgcv]{te}}).
#' 
#' The predict matrix function return a cross-basis matrix evaluated at
#' specific values used for prediction.
#' @note Identifiability constraints are applied to marginal basis for
#' predictor (see \code{\link[mgcv]{smoothCon}}), while the marginal basis for
#' the lag dimension is left untransformed. This involves a re-parameterization
#' with the absorption of constraints into the basis that causes its dimension
#' to decrease by 1. Note that this procedure is similar to that in
#' \code{\link{crossbasis}}, while it is different than in standard tensor
#' product smooths (see \code{\link[mgcv]{te}}), where identifiability
#' constraints are not applied to the marginal bases.
#' 
#' Using the default specification with \code{k=10} in the smooth terms defined
#' by \code{\link[mgcv]{s}}, the dimension of the cross-basis matrix will be
#' \eqn{(10-1) \times 10 = 90}{(10-1)x10=90} (accounting for identifiability
#' constraints). This is consistent with the rationale that this choice is not
#' important as far as the upper limit for the degrees of freedom in each
#' marginal basis is large enough to represent the underlying relationship (see
#' \code{\link[mgcv]{choose.k}}). Smaller values of \code{k} can be used for
#' speeding up the computation, as long as the underlying relationship can be
#' assumed to be smooth enough.
#' 
#' These functions provide an \emph{internal} method for performing penalized
#' DLMs and DLNMs, with the cross-basis spline smoother defined directly in the
#' model formula of \code{\link[mgcv]{gam}} through a smooth term specified by
#' \code{\link[mgcv]{s}}. The alternative \emph{external} method relies on the
#' standard use of \code{\link{crossbasis}} and on the penalization of
#' so-called parametric terms through the argument \code{paraPen} of
#' \code{\link[mgcv]{gam}} (see \code{\link{cbPen}} for details). The two
#' methods are expected to returns almost identical results in most cases.
#' However, while the internal method takes advantage of the full machinery of
#' \pkg{mgcv} and plausibly more stable procedures, the external method allows
#' more flexibility and the optional use of user-defined smoothers.
#' @author Antonio Gasparrini <\email{antonio.gasparrini@@lshtm.ac.uk}> and
#' Fabian Scheipl <\email{fabian.scheipl@@stat.uni-muenchen.de}>
#' @seealso Smooth constructors for
#' \code{\link[=smooth.construct.ps.smooth.spec]{P-splines}} and
#' \code{\link[=smooth.construct.cr.smooth.spec]{cubic regression splines}} in
#' \pkg{mgcv}. \code{\link{ps}} and \code{\link{cr}} for the same functions
#' available in \pkg{dlnm}. \code{\link{cbPen}} for defining tensor-type
#' bi-dimensional penalties in DLNMs.
#' 
#' See \code{\link{dlnm-package}} for an introduction to the package and for
#' links to package vignettes providing more detailed information.
#' @references Gasparrini A. A penalized framework for distributed lag
#' non-linear models. \emph{Biometrics}. 2016; in press.
#' 
#' Wood S. N. Generalized Additive Models: An Introduction with R. Chapman and
#' Hall/CRC Press, 2006.
#' @keywords smooth models regression
#' @importFrom mgcv s smoothCon smooth.construct tensor.prod.model.matrix
#' @examples
#' 
#' rnorm(1)
#' 
smooth.construct.cb.smooth.spec <- function(object, data, knots) {
#
################################################################################
#
  # CHECK THAT THE SMOOTHER IS APPLIED TO A SINGLE TERM
  if(length(object$term)!=2L) stop("'cb' smoother only accepts two terms")
#
  # CHECK FOR argvar AND arglag OBJECTS IN xt
  argvar <- object$xt$argvar
  arglag <- object$xt$arglag
#
  # PREVENT USE OF by
  if(object$by!="NA") stop("'by' argument not (yet) applicable with 'cb' smoother")
#
################################################################################
# DEFINE ARGUMENTS FOR BUILDING MARGINAL BASES: term, k, fx, bs, m (NO xt NEEDED)
#
  # TERMS AND DIMENSIONS
  term <- object$term
  dim <- length(term)
#
  # EVALUATE k (FROM bs.dim, DEFAULT TO 10)
  k <- object$bs.dim
  k[k<0] <- 10
  if(length(k)==1) k <- rep(k,2)
#
  # EVALUATE bs (STORED IN xt, DEFAULT TO 'ps', AND ONLY 'ps'-'cr' ACCEPTED)
  bs <- object$xt$bs
  if(is.null(bs)) bs <- "ps" else if(!all(bs%in%c("ps","cr"))) 
      stop("only 'ps' and 'cr' smoothers accepted within 'cb'")
  if(length(bs)==1) bs <- rep(bs,2)
#
  # EVALUATE m (FROM p.order)
  m <- object$p.order
  if(!is.list(m)&&length(m)==1) m <- rep(m,2)
#
  # EVALUATE fx (FROM fixed)
  fx <- object$fixed
  if(sum(is.na(fx))||is.null(fx)) fx <- rep(FALSE,2) else 
    if(length(fx)==1) fx <- rep(fx,2)
#
################################################################################
# BUILD THE MARGINAL BASES
#
  # SET EMPTY LISTS TO STORE THE RESULTS
  margin <- dat <- knt <- Xm <- Sm <- list(var=NULL,lag=NULL)
  # SET EMPTY OBJECT TO STORE INFO ON DIMENSIONS, RANK, NULL SPACE
  # NB: SOME LEFT 0 (THEREFORE NOT SET) FOR PARAMETRIC SMOOTHERS
  d <- r <- nr <- rep(0,2)
  # SET CONSTRAINTS
  mc <- c(TRUE,FALSE)
  C <- matrix(0,0,0)
#
  # MARGINAL BASES
  # IF SMOOTHER NOT DEFINED THROUGH xt LIST, USE THE STANDARD METHOD
  # OTHERWISE, USE onebasis FOR PARAMETRIC SMOOTHERS 
  for(i in seq(dim)) {
    xtarg <- if(i==1) argvar else arglag
    dat <- data[term[i]]
    knt <- knots[term[i]]
    if(is.null(xtarg)) {
      sobj <- do.call(s,list(as.name(term[i]),k=k[i],fx=fx[i],bs=bs[i],m=m[[i]]))
      margin[[i]] <- if(mc[i]) smoothCon(sobj,dat,knt,absorb.cons=TRUE,
        n=length(dat[[1]]))[[1]] else smooth.construct(sobj,dat,knt)
      Xm[[i]] <- margin[[i]]$X
      if(!fx[i]) Sm[[i]] <- margin[[i]]$S[[1]]
      d[i] <- ncol(margin[[i]]$X)
      r[i] <- margin[[i]]$rank
      nr[i] <- margin[[i]]$null.space.dim
    } else {
      # IF arglag, ADD AN INTERCEPT IF APPROPRIATE
      if(i==2&&(is.null(xtarg$fun)||"intercept"%in%names(formals(xtarg$fun)))&&
          sum(pmatch(names(xtarg),"intercept",nomatch=0))==0) 
        xtarg$intercept <- TRUE
      Xm[[i]] <- do.call("onebasis",modifyList(xtarg,list(x=dat[[term[i]]])))
      attr <- attributes(Xm[[i]])
      ind <- match(c("fun",names(formals(attr$fun))),names(attr),nomatch=0)
      margin[[i]] <- attr[ind]
      class(margin[[i]]) <- "onebasis"
      if(!attr$fun%in%c("ps","cr")) fx[i] <- TRUE
      if(!fx[i]) Sm[[i]] <- attr$S
      d[i] <- nr[i] <- ncol(Xm[[i]])
    }
  }
#
################################################################################
# BUILD TENSOR AND PENALTY MATRICES
#
  # TENSOR (USING mgcv FUNCTION)
  # NB: REMOVING NAMES SPEEDS UP THE TENSOR COMPUTATION SUBSTANTIALLY
  X <- tensor.prod.model.matrix(unname(Xm))
#
  # PENALTY MATRICES: FIRST RESCALE, THEN EXPAND (AS tensor.prod.penalties)
  S <- list()
  if(!fx[1]) {
    Sm[[1]] <- Sm[[1]]/eigen(Sm[[1]],symmetric=TRUE,only.values=TRUE)$values[1]
    S <- c(S,list(Svar=Sm[[1]]%x%diag(d[2])))
  }
  if(!fx[2]) {
    Sm[[2]] <- Sm[[2]]/eigen(Sm[[2]],symmetric=TRUE,only.values=TRUE)$values[1]
    S <- c(S,list(Slag=diag(d[1])%x%Sm[[2]]))
  }
#
  # RANK
  max.rank <- prod(d)
  r <- max.rank*r/d
  r <- r[!fx]
  nr <-  prod(nr)
#
  # ADDITIONAL PENALTIES ON THE LAG STRUCTURE
  if(!is.null(object$xt$addSlag)) {
    addS <- mkaddSlag(object$xt$addSlag,d)
    S <- c(S,addS)
    r <- c(r,sapply(addS,findrank))
  }
#
  # ERASE MARGINAL BASIS AND PENALTY MATRICES TO SAVE MEMORY
  for(i in seq(dim)) margin[[i]]$X <- margin[[i]]$S <- NULL
#
################################################################################
# ADD OTHER INFO AND SET OTHER FEATURES OF TENSOR
#
  # BUILD THE OBJECT (SOME INFO IN THE ORIGINAL SMOOTH SPEC OBJECT)
  # NB:
  #   - np SET TO FALSE (NO REPARAMETERIZATION), SO XP=list()
  #   - plot.me DOES NOT ALLOW (YET) PLOTTING USING mgcv FUNCTIONS
  ret <- list(margin=margin,term=term,by=object$by,fx=fx,label=object$label,
    dim=dim,mp=TRUE,np=FALSE,id=object$id,sp=object$sp,inter=TRUE,mc=mc,
    plot.me=FALSE,X=X,S=S,C=C,df=ncol(X),null.space.dim=nr,rank=r,XP=list())
#
  # ADD ADDITIONAL ATTRIBUTES SPECIFIC TO cb SMOOTHER
  ret$lag <- range(data[[term[2]]])
#
  # CLASS
  class(ret) <- c("cb.smooth","tensor.smooth")
#
  return(ret)
}
